# Wallet Sandbox - Standards for Cursor AI

This file provides guidelines for Cursor AI when generating or modifying code in the Wallet Sandbox project.

## Main Rules

1. Refer to specific rules files for each aspect of the project:
   - `.cursor/rules/wallet-standards.md`: Build, development and Git standards
   - `.cursor/rules/playwright-tests.md`: Specific standards for Playwright tests

## Change Management and Git Workflow

1. **Verify User Story (US)**:
   - ALWAYS ask for the US/TT/BG being implemented
   - Verify its existence in `BACKLOG.md` or GitHub Issues
   - If it doesn't exist, suggest creating a new one following the standard format

2. **Git Workflow**:
   - ALWAYS start from updated main branch
   - Create branch with name `type/US-XXX-short-description`
   - Make commits with format `[US-XXX] Concise description`
   - Request confirmation before publishing
   - Add GitHub Copilot as reviewer in PRs

## Next.js 15 Standards

- ALWAYS use App Router and Server Components by default
- For dynamic routes, ALWAYS await params
- Structure components with: hooks, handlers, early returns, rendering
- Use Server Actions for data modification
- Use Tailwind CSS and shadcn/ui components

## Playwright Test Standards

- Each test MUST be completely independent and self-contained
- NEVER create tests that depend on other tests run previously
- Each test MUST have a single responsibility (test ONE thing)
- Use Page Object Model patterns to organize tests
- Prioritize role-based locators (getByRole)
- Use auto-waiting assertions

## Test Naming Requirements

- Test names MUST be descriptive and explain the behavior being tested
- NEVER use numeric prefixes in test titles (e.g., "TC1:", "Test 2:", etc.)
- Test names should not imply any execution order
- Example: Use `test('User cannot login with invalid credentials')` instead of `test('TC2: User cannot login with invalid credentials')`

## Locator Preferences

1. Use role-based locators whenever possible:
```typescript
await page.getByRole('button', { name: 'Submit' }).click();
await page.getByRole('textbox', { name: 'Email' }).fill('user@example.com');
```

2. Use test IDs when role-based locators are insufficient:
```typescript
await page.getByTestId('submit-button').click();
```

3. Use text content as a fallback:
```typescript
await page.getByText('Welcome').isVisible();
```

4. Avoid CSS selectors and XPath when possible

## Page Object Implementation

Generate page objects following this pattern:
```typescript
import { Page } from '@playwright/test';

export class LoginPage {
  readonly path = '/login';
  
  constructor(private page: Page) {}
  
  // Locators
  private get emailInput() { return this.page.getByRole('textbox', { name: 'Email' }); }
  private get passwordInput() { return this.page.getByRole('textbox', { name: 'Password' }); }
  private get loginButton() { return this.page.getByRole('button', { name: 'Login' }); }
  
  // Actions
  async goto() {
    await this.page.goto(this.path);
  }
  
  async login(email: string, password: string) {
    await this.emailInput.fill(email);
    await this.passwordInput.fill(password);
    await this.loginButton.click();
  }
}
```

## Assertion Preferences

- Use built-in Playwright assertions
- Prefer auto-waiting assertions over manual waits
- Check visibility before interacting with elements

```typescript
// Preferred
await expect(page.getByText('Success')).toBeVisible();

// Avoid
await page.waitForTimeout(1000);
```

## API Mocking

Use Playwright's route handling to mock API responses:

```typescript
// Mock API responses
await page.route('**/api/endpoint', (route) => {
  route.fulfill({
    status: 200,
    contentType: 'application/json',
    body: JSON.stringify({ key: 'value' })
  });
});
```

Create test cases that use mocked API responses:
- Mock success responses for happy path tests
- Mock error responses to test error handling
- Mock empty responses to test edge cases
- Validate request payloads when testing form submissions

## MCP (Model Context Protocol) Usage

When generating tests with MCP, follow these guidelines:

- Use natural language descriptions for test steps
- Leverage the accessibility tree in Snapshot Mode (default)
- Use Vision Mode only when necessary for visual interactions
- Include error handling and edge cases

For more detailed standards, refer to the files in .github/copilot/ directory.
